<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tennis AI Coach - Motion Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            text-align: center;
            position: relative;
        }
        
        .technique-selection {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .technique-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .technique-header h3 {
            color: #2d3748;
            font-size: 18px;
            margin-bottom: 8px;
        }
        
        .technique-header p {
            color: #718096;
            font-size: 14px;
        }
        
        .technique-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .technique-card {
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
        }
        
        .technique-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.15);
            border-color: #cbd5e0;
        }
        
        .technique-card.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.4);
        }
        
        .technique-card.selected .technique-icon {
            transform: scale(1.1);
        }
        
        .technique-icon {
            font-size: 24px;
            margin-bottom: 8px;
            transition: transform 0.3s ease;
        }
        
        .technique-name {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
        }
        
        .technique-name-en {
            font-size: 11px;
            opacity: 0.8;
        }
        
        .technique-card.selected .technique-name-en {
            opacity: 0.9;
        }
        
        .selected-technique-info {
            background: #e6fffa;
            border: 1px solid #81e6d9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }
        
        .selected-technique-info.show {
            display: block;
            animation: fadeInUp 0.3s ease;
        }
        
        .selected-technique-info h4 {
            color: #2d3748;
            font-size: 16px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }
        
        .analysis-disabled {
            opacity: 0.6;
            pointer-events: none;
        }
        
        .selection-required {
            background: #fed7d7;
            border: 1px solid #feb2b2;
            color: #c53030;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            margin-bottom: 15px;
            display: none;
        }
        
        .selection-required.show {
            display: block;
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .language-switch {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            background: rgba(103, 126, 234, 0.1);
            border-radius: 20px;
            padding: 3px;
            gap: 2px;
        }
        
        .lang-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            background: transparent;
            color: #667eea;
        }
        
        .lang-btn.active {
            background: #667eea;
            color: white;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .lang-btn:hover:not(.active) {
            background: rgba(103, 126, 234, 0.1);
        }
        
        .header h1 {
            color: #2d3748;
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .header .subtitle {
            color: #718096;
            font-size: 16px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .video-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .video-container {
            position: relative;
            background: #1a202c;
            border-radius: 12px;
            height: 400px;
            margin-bottom: 15px;
            overflow: hidden;
            max-width: 100%;
        }
        
        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 12px;
        }
        
        #uploadVideoElement {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 12px;
        }
        
        #uploadVideoElement {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 12px;
        }
        
        #canvasElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #uploadCanvasElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .video-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #a0aec0;
            text-align: center;
            font-size: 16px;
            max-width: 90%;
            padding: 20px;
        }
        
        .video-placeholder small {
            font-size: 12px;
            display: block;
            margin-top: 8px;
        }
        
        .camera-controls {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        
        .camera-switch-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 20px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: none;
            align-items: center;
            gap: 5px;
        }
        
        .camera-switch-btn.show {
            display: flex;
        }
        
        .camera-switch-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.05);
        }
        
        .upload-area {
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-bottom: 15px;
            background: #f7fafc;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #667eea;
            background: #edf2f7;
        }
        
        .upload-area.dragover {
            border-color: #667eea;
            background: #e6fffa;
        }
        
        #fileInput {
            display: none;
        }
        
        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .video-controls {
            display: none;
            background: #f7fafc;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .video-controls.show {
            display: block;
        }
        
        .progress-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .progress-bar {
            flex: 1;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            overflow: hidden;
            cursor: pointer;
        }
        
        .progress-fill {
            height: 100%;
            background: #667eea;
            width: 0%;
            transition: width 0.1s ease;
        }
        
        .time-display {
            font-size: 12px;
            color: #4a5568;
            min-width: 80px;
        }
        
        .playback-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: #cbd5e0;
        }
        
        .btn-success {
            background: #48bb78;
            color: white;
        }
        
        .btn-danger {
            background: #e53e3e;
            color: white;
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }
        
        .analysis-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .analysis-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .score-circle {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: conic-gradient(#48bb78 0deg 252deg, #e2e8f0 252deg 360deg);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 15px;
            position: relative;
            transition: all 0.5s ease;
        }
        
        .score-inner {
            width: 90px;
            height: 90px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        
        .score-number {
            font-size: 28px;
            font-weight: bold;
            color: #2d3748;
        }
        
        .score-label {
            font-size: 12px;
            color: #718096;
        }
        
        .metrics {
            margin-bottom: 20px;
        }
        
        .metric-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .metric-item:last-child {
            border-bottom: none;
        }
        
        .metric-label {
            color: #4a5568;
            font-size: 14px;
        }
        
        .metric-value {
            color: #2d3748;
            font-weight: 600;
            font-size: 14px;
        }
        
        .metric-bar {
            width: 80px;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-left: 10px;
        }
        
        .metric-fill {
            height: 100%;
            background: linear-gradient(90deg, #48bb78, #38a169);
            border-radius: 4px;
            transition: width 0.5s ease;
            width: 0%;
        }
        
        .suggestions {
            background: #f7fafc;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .suggestions h3 {
            color: #2d3748;
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .suggestion-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 14px;
            color: #4a5568;
            opacity: 0;
            transform: translateY(10px);
            animation: fadeInUp 0.5s ease forwards;
        }
        
        .suggestion-item:nth-child(2) { animation-delay: 0.1s; }
        .suggestion-item:nth-child(3) { animation-delay: 0.2s; }
        .suggestion-item:nth-child(4) { animation-delay: 0.3s; }
        
        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .suggestion-icon {
            width: 16px;
            height: 16px;
            background: #667eea;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .status-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 5px 10px;
            background: rgba(72, 187, 120, 0.1);
            color: #38a169;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            z-index: 10;
        }
        
        .analysis-progress {
            display: none;
            background: #e6fffa;
            border: 1px solid #81e6d9;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .analysis-progress.show {
            display: block;
        }
        
        .progress-spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #e2e8f0;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e2e8f0;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        .error-message {
            background: #fed7d7;
            border: 1px solid #feb2b2;
            color: #c53030;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        
        .mode-tabs {
            display: flex;
            background: #f7fafc;
            border-radius: 8px;
            padding: 4px;
            margin-bottom: 20px;
        }
        
        .mode-tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 14px;
        }
        
        .mode-tab.active {
            background: white;
            color: #667eea;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .mode-tab:not(.active) {
            color: #718096;
        }
        
        .mode-content {
            display: none;
        }
        
        .mode-content.active {
            display: block;
        }
        
        .camera-indicator {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 11px;
            font-weight: 500;
            display: none;
            z-index: 10;
        }
        
        .camera-indicator.show {
            display: block;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .controls {
                gap: 8px;
            }
            
            .btn {
                padding: 8px 12px;
                font-size: 12px;
            }
            
            .video-container {
                height: 250px;
                max-height: 50vh;
            }
            
            .mode-tabs {
                flex-direction: column;
            }
            
            .camera-switch-btn {
                font-size: 11px;
                padding: 6px 10px;
            }
            
            .app-container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 24px;
            }
            
            .header .subtitle {
                font-size: 14px;
            }
            
            .language-switch {
                top: 12px;
                right: 12px;
            }
            
            .analysis-panel {
                padding: 15px;
            }
            
            .video-section {
                padding: 15px;
            }
            
            .technique-selection {
                padding: 15px;
            }
            
            .technique-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            
            .technique-card {
                padding: 12px;
            }
            
            .technique-icon {
                font-size: 20px;
            }
            
            .technique-name {
                font-size: 13px;
            }
            
            .technique-name-en {
                font-size: 10px;
            }
        }
        
        @media (max-width: 480px) {
            .video-container {
                height: 200px;
                max-height: 40vh;
            }
            
            .score-circle {
                width: 100px;
                height: 100px;
            }
            
            .score-inner {
                width: 75px;
                height: 75px;
            }
            
            .score-number {
                font-size: 24px;
            }
            
            .btn {
                padding: 6px 10px;
                font-size: 11px;
            }
            
            .metric-bar {
                width: 60px;
            }
            
            .video-placeholder {
                font-size: 14px;
                padding: 15px;
            }
            
            .video-placeholder small {
                font-size: 11px;
            }
            
            .language-switch {
                top: 10px;
                right: 10px;
                transform: scale(0.9);
            }
            
            .lang-btn {
                padding: 4px 8px;
                font-size: 10px;
            }
            
            .technique-selection {
                padding: 12px;
            }
            
            .technique-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .technique-card {
                padding: 10px;
            }
            
            .technique-icon {
                font-size: 18px;
            }
            
            .technique-name {
                font-size: 12px;
            }
            
            .technique-name-en {
                font-size: 9px;
            }
            
            .technique-header h3 {
                font-size: 16px;
            }
            
            .technique-header p {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <div class="language-switch">
                <button class="lang-btn active" data-lang="en">EN</button>
                <button class="lang-btn" data-lang="zh">中文</button>
            </div>
            <h1 data-text="title">🎾 Tennis AI Coach</h1>
            <p class="subtitle" data-text="subtitle">AI-powered tennis technique analysis and coaching - Support live camera and video file analysis</p>
        </div>
        
        <!-- Error Message -->
        <div class="error-message" id="errorMessage"></div>
        
        <!-- Technique Selection -->
        <div class="technique-selection">
            <div class="technique-header">
                <h3 data-text="selectTechnique">Select Tennis Technique</h3>
                <p data-text="selectTechniqueDesc">Choose the specific technique you want to analyze for more accurate results</p>
            </div>
            
            <div class="technique-grid">
                <div class="technique-card" data-technique="serve">
                    <div class="technique-icon">🎾</div>
                    <div class="technique-name" data-text="serve">Serve</div>
                    <div class="technique-name-en" data-text="serveEn">发球</div>
                </div>
                
                <div class="technique-card" data-technique="forehand">
                    <div class="technique-icon">🏸</div>
                    <div class="technique-name" data-text="forehand">Forehand</div>
                    <div class="technique-name-en" data-text="forehandEn">正手击球</div>
                </div>
                
                <div class="technique-card" data-technique="backhand">
                    <div class="technique-icon">🎯</div>
                    <div class="technique-name" data-text="backhand">Backhand</div>
                    <div class="technique-name-en" data-text="backhandEn">反手击球</div>
                </div>
                
                <div class="technique-card" data-technique="volley">
                    <div class="technique-icon">⚡</div>
                    <div class="technique-name" data-text="volley">Volley</div>
                    <div class="technique-name-en" data-text="volleyEn">截击球</div>
                </div>
                
                <div class="technique-card" data-technique="slice">
                    <div class="technique-icon">🌀</div>
                    <div class="technique-name" data-text="slice">Slice</div>
                    <div class="technique-name-en" data-text="sliceEn">切削球</div>
                </div>
                
                <div class="technique-card" data-technique="overhead">
                    <div class="technique-icon">💥</div>
                    <div class="technique-name" data-text="overhead">Overhead Smash</div>
                    <div class="technique-name-en" data-text="overheadEn">高压球</div>
                </div>
            </div>
            
            <div class="selected-technique-info" id="selectedTechniqueInfo">
                <h4 id="selectedTechniqueName">
                    <span>🎾</span>
                    <span data-text="selectedTechniqueTitle">Analysis Focus</span>
                </h4>
                <p style="color: #4a5568; font-size: 14px; text-align: center; margin-top: 8px;" data-text="techniqueSelectedDesc">
                    Analysis metrics will update to focus on this specific technique
                </p>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <!-- Video Analysis Section -->
            <div class="video-section">
                <!-- Selection Required Warning -->
                <div class="selection-required" id="selectionRequired">
                    <span data-text="techniqueRequired">⚠️ Please select a tennis technique above before starting analysis</span>
                </div>
                
                <!-- Mode Tabs -->
                <div class="mode-tabs">
                    <div class="mode-tab active" data-mode="camera" data-text="liveCameraTab">📹 Live Camera</div>
                    <div class="mode-tab" data-mode="upload" data-text="uploadVideoTab">📁 Upload Video</div>
                </div>
                
                <!-- Camera Mode -->
                <div class="mode-content active" id="cameraMode">
                    <div class="video-container">
                        <div class="camera-controls">
                            <button class="camera-switch-btn" id="cameraSwitchBtn" data-text="switchCamera">
                                🔄 Switch Camera
                            </button>
                        </div>
                        <div class="status-indicator" id="statusIndicator" data-text="ready">Ready</div>
                        <div class="camera-indicator" id="cameraIndicator" data-text="frontCamera">Front Camera</div>
                        <video id="videoElement" autoplay muted playsinline style="display: none;"></video>
                        <canvas id="canvasElement"></canvas>
                        <div class="video-placeholder" id="placeholder">
                            <span data-text="cameraPlaceholder">📹<br>Click to start camera analysis<br></span>
                            <small data-text="cameraPlaceholderSmall">Real-time tennis motion recognition</small>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-primary" id="startBtn" data-text="startAnalysis">
                            🎥 Start Analysis
                        </button>
                        <button class="btn btn-danger" id="stopBtn" style="display: none;" data-text="stopAnalysis">
                            ⏹️ Stop Analysis
                        </button>
                        <button class="btn btn-secondary" id="resetBtn" data-text="reset">
                            🔄 Reset
                        </button>
                    </div>
                </div>
                
                <!-- Upload Video Mode -->
                <div class="mode-content" id="uploadMode">
                    <div class="upload-area" id="uploadArea">
                        <div class="upload-icon">📁</div>
                        <p style="margin-bottom: 10px; color: #4a5568; font-weight: 500;" data-text="uploadText">Click or drag to upload video file</p>
                        <p style="font-size: 12px; color: #718096;" data-text="uploadFormat">Support MP4, MOV, AVI formats, max file size 50MB</p>
                        <input type="file" id="fileInput" accept="video/*">
                    </div>
                    
                    <div class="video-container" id="uploadVideoContainer" style="display: none;">
                        <div class="status-indicator" id="uploadStatusIndicator" data-text="videoLoaded">Video Loaded</div>
                        <video id="uploadVideoElement" controls></video>
                        <canvas id="uploadCanvasElement"></canvas>
                    </div>
                    
                    <div class="video-controls" id="videoControls">
                        <div class="progress-container">
                            <span class="time-display" id="currentTime">00:00</span>
                            <div class="progress-bar" id="progressBar">
                                <div class="progress-fill" id="progressFill"></div>
                            </div>
                            <span class="time-display" id="totalTime">00:00</span>
                        </div>
                        <div class="playback-controls">
                            <button class="btn btn-secondary btn-small" id="playPauseBtn" data-text="play">▶️ Play</button>
                            <button class="btn btn-primary btn-small" id="analyzeVideoBtn" data-text="analyzeVideo">🔍 Analyze Video</button>
                            <button class="btn btn-secondary btn-small" id="clearVideoBtn" data-text="clear">🗑️ Clear</button>
                        </div>
                    </div>
                    
                    <div class="analysis-progress" id="analysisProgress">
                        <div class="progress-spinner"></div>
                        <p style="color: #2d3748; font-weight: 500; margin-bottom: 5px;" data-text="analyzingVideo">Analyzing video...</p>
                        <p style="color: #718096; font-size: 14px;" id="analysisProgressText" data-text="processingWait">Processing, please wait</p>
                    </div>
                </div>
                
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <p data-text="loadingAI">Loading AI model...</p>
                </div>
            </div>
            
            <!-- Analysis Results Panel -->
            <div class="analysis-panel">
                <div class="analysis-header">
                    <div class="score-circle" id="scoreCircle">
                        <div class="score-inner">
                            <div class="score-number" id="scoreNumber">--</div>
                            <div class="score-label" data-text="overallScore">Overall Score</div>
                        </div>
                    </div>
                    <h3 style="color: #2d3748; margin-bottom: 5px;" id="analysisTitle" data-text="selectAnalysisMode">Select Analysis Mode</h3>
                    <p style="color: #718096; font-size: 14px;" id="analysisDesc" data-text="chooseMode">Choose live camera or upload video for motion analysis</p>
                </div>
                
                <div class="metrics">
                    <div class="metric-item">
                        <span class="metric-label" data-text="postureStability">Posture Stability</span>
                        <div style="display: flex; align-items: center;">
                            <span class="metric-value" id="stabilityValue">--</span>
                            <div class="metric-bar">
                                <div class="metric-fill" id="stabilityFill"></div>
                            </div>
                        </div>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label" data-text="motionFluidity">Motion Fluidity</span>
                        <div style="display: flex; align-items: center;">
                            <span class="metric-value" id="fluidityValue">--</span>
                            <div class="metric-bar">
                                <div class="metric-fill" id="fluidityFill"></div>
                            </div>
                        </div>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label" data-text="coordination">Coordination</span>
                        <div style="display: flex; align-items: center;">
                            <span class="metric-value" id="coordinationValue">--</span>
                            <div class="metric-bar">
                                <div class="metric-fill" id="coordinationFill"></div>
                            </div>
                        </div>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label" data-text="technicalAccuracy">Technical Accuracy</span>
                        <div style="display: flex; align-items: center;">
                            <span class="metric-value" id="accuracyValue">--</span>
                            <div class="metric-bar">
                                <div class="metric-fill" id="accuracyFill"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="suggestions">
                    <h3 data-text="analysisSuggestions">💡 Analysis Suggestions</h3>
                    <div id="suggestionsList">
                        <div class="suggestion-item">
                            <div class="suggestion-icon"></div>
                            <span data-text="selectModeForSuggestions">Select analysis mode to see motion suggestions</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

    <script>
        // Language Configuration
        const languages = {
            en: {
                title: '🎾 Tennis AI Coach',
                subtitle: 'AI-powered tennis technique analysis and coaching - Support live camera and video file analysis',
                
                // Technique Selection
                selectTechnique: 'Select Tennis Technique',
                selectTechniqueDesc: 'Choose the specific technique you want to analyze for more accurate results',
                serve: 'Serve',
                serveEn: '发球',
                forehand: 'Forehand',
                forehandEn: '正手击球',
                backhand: 'Backhand',
                backhandEn: '反手击球',
                volley: 'Volley',
                volleyEn: '截击球',
                slice: 'Slice',
                sliceEn: '切削球',
                overhead: 'Overhead Smash',
                overheadEn: '高压球',
                selectedTechniqueTitle: 'Analysis Focus',
                techniqueRequired: '⚠️ Please select a tennis technique above before starting analysis',
                
                liveCameraTab: '📹 Live Camera',
                uploadVideoTab: '📁 Upload Video',
                switchCamera: '🔄 Switch Camera',
                ready: 'Ready',
                frontCamera: 'Front Camera',
                rearCamera: 'Rear Camera',
                cameraPlaceholder: '📹<br>Click to start camera analysis<br>',
                cameraPlaceholderSmall: 'Real-time tennis motion recognition',
                startAnalysis: '🎥 Start Analysis',
                stopAnalysis: '⏹️ Stop Analysis',
                reset: '🔄 Reset',
                uploadText: 'Click or drag to upload video file',
                uploadFormat: 'Support MP4, MOV, AVI formats, max file size 50MB',
                videoLoaded: 'Video Loaded',
                play: '▶️ Play',
                pause: '⏸️ Pause',
                analyzeVideo: '🔍 Analyze Video',
                clear: '🗑️ Clear',
                analyzingVideo: 'Analyzing video...',
                processingWait: 'Processing, please wait',
                overallScore: 'Overall Score',
                selectAnalysisMode: 'Select Analysis Mode',
                chooseMode: 'Choose live camera or upload video for motion analysis',
                
                // General metrics (fallback)
                postureStability: 'Posture Stability',
                motionFluidity: 'Motion Fluidity',
                coordination: 'Coordination',
                technicalAccuracy: 'Technical Accuracy',
                
                // Serve specific metrics
                serveMetric1: 'Ball Toss Stability',
                serveMetric2: 'Body Coordination',
                serveMetric3: 'Landing Accuracy',
                
                // Forehand specific metrics
                forehandMetric1: 'Preparation & Backswing',
                forehandMetric2: 'Contact Point Position',
                forehandMetric3: 'Follow-through Motion',
                
                // Backhand specific metrics
                backhandMetric1: 'Grip Position',
                backhandMetric2: 'Weight Transfer',
                backhandMetric3: 'Contact Point Control',
                
                // Volley specific metrics
                volleyMetric1: 'Footwork Adjustment',
                volleyMetric2: 'Racket Face Control',
                volleyMetric3: 'Contact Point Height',
                
                // Slice specific metrics
                sliceMetric1: 'Racket Face Angle',
                sliceMetric2: 'Swing Trajectory',
                sliceMetric3: 'Spin Consistency',
                
                // Overhead specific metrics
                overheadMetric1: 'Footwork Speed',
                overheadMetric2: 'Contact Height',
                overheadMetric3: 'Power & Control',
                
                analysisSuggestions: '💡 Analysis Suggestions',
                selectModeForSuggestions: 'Select analysis mode to see motion suggestions',
                loadingAI: 'Loading AI model...',
                
                // Status messages
                startingCamera: 'Starting camera...',
                analyzing: 'Analyzing...',
                stopped: 'Stopped',
                
                // Analysis modes
                liveCameraMode: 'Live Camera Mode',
                videoFileMode: 'Video File Mode',
                clickToStart: 'Click start to begin real-time motion analysis',
                uploadForAnalysis: 'Upload a video file for motion analysis',
                realTimeAnalysis: 'Real-time Motion Analysis',
                videoAnalysisComplete: 'Video Analysis Complete',
                
                // Suggestions
                keepStable: 'Keep your body center stable, maintain firm footing',
                makeFluid: 'Make your movements more fluid, avoid sudden stops',
                focusCoordination: 'Focus on coordinating all body parts together',
                improveStroke: 'Improve stroke technique, extend arms fully',
                greatTechnique: 'Great technique! Keep it up!',
                
                // Analysis descriptions
                excellentTechnique: 'Excellent technique, keep it up!',
                goodForm: 'Good form, continue refining details',
                basicCorrect: 'Basic technique correct, needs improvement',
                needsAdjustment: 'Technique needs adjustment, follow suggestions',
                studyTutorials: 'Recommend studying tutorial videos for basic techniques',
                
                // Error messages
                initFailed: 'Initialization failed: ',
                cameraAccess: 'Cannot access camera: ',
                switchFailed: 'Failed to switch camera: ',
                startFirst: 'Please start camera analysis first',
                selectVideo: 'Please select a valid video file',
                fileSizeLimit: 'File size cannot exceed 50MB',
                uploadFirst: 'Please upload a video file first',
                videoAnalysisFailed: 'Video analysis failed: ',
                noValidData: 'No valid motion data detected. Please ensure the video shows clear human movements',
                noValidMovements: 'No valid movements found in video. Please upload a video with clear human motion',
                loadFailed: 'Failed to load video: ',
                selectTechniqueFirst: 'Please select a tennis technique first'
            },
            zh: {
                title: '🎾 网球智能陪练',
                subtitle: 'AI驱动的网球技术分析与指导 - 支持实时摄像头和视频文件分析',
                
                // Technique Selection
                selectTechnique: '选择网球技术动作',
                selectTechniqueDesc: '选择您要分析的具体技术动作，以获得更准确的分析结果',
                serve: '发球',
                serveEn: 'Serve',
                forehand: '正手击球',
                forehandEn: 'Forehand',
                backhand: '反手击球',
                backhandEn: 'Backhand',
                volley: '截击球',
                volleyEn: 'Volley',
                slice: '切削球',
                sliceEn: 'Slice',
                overhead: '高压球',
                overheadEn: 'Overhead Smash',
                selectedTechniqueTitle: '分析重点',
                techniqueRequired: '⚠️ 请先在上方选择一个网球技术动作再开始分析',
                
                liveCameraTab: '📹 实时摄像头',
                uploadVideoTab: '📁 上传视频',
                switchCamera: '🔄 切换摄像头',
                ready: '准备就绪',
                frontCamera: '前置摄像头',
                rearCamera: '后置摄像头',
                cameraPlaceholder: '📹<br>点击开始摄像头分析<br>',
                cameraPlaceholderSmall: '实时网球动作识别',
                startAnalysis: '🎥 开始分析',
                stopAnalysis: '⏹️ 停止分析',
                reset: '🔄 重置',
                uploadText: '点击或拖拽上传视频文件',
                uploadFormat: '支持 MP4, MOV, AVI 格式，建议文件大小不超过 50MB',
                videoLoaded: '视频已加载',
                play: '▶️ 播放',
                pause: '⏸️ 暂停',
                analyzeVideo: '🔍 分析视频',
                clear: '🗑️ 清除',
                analyzingVideo: '正在分析视频...',
                processingWait: '处理中，请稍候',
                overallScore: '综合评分',
                selectAnalysisMode: '选择分析模式',
                chooseMode: '实时摄像头或上传视频进行动作分析',
                
                // General metrics (fallback)
                postureStability: '姿势稳定性',
                motionFluidity: '动作流畅度',
                coordination: '协调性',
                technicalAccuracy: '技术准确性',
                
                // Serve specific metrics
                serveMetric1: '抛球稳定性',
                serveMetric2: '身体协调性',
                serveMetric3: '落点精准度',
                
                // Forehand specific metrics
                forehandMetric1: '准备动作和引拍',
                forehandMetric2: '击球点位置',
                forehandMetric3: '随挥动作',
                
                // Backhand specific metrics
                backhandMetric1: '握拍姿势',
                backhandMetric2: '重心控制',
                backhandMetric3: '击球点控制',
                
                // Volley specific metrics
                volleyMetric1: '步伐调整',
                volleyMetric2: '拍面控制',
                volleyMetric3: '击球点高度',
                
                // Slice specific metrics
                sliceMetric1: '拍面角度',
                sliceMetric2: '挥拍轨迹',
                sliceMetric3: '球旋转一致性',
                
                // Overhead specific metrics
                overheadMetric1: '步伐速度',
                overheadMetric2: '击球高度',
                overheadMetric3: '力量与控制',
                
                analysisSuggestions: '💡 分析建议',
                selectModeForSuggestions: '选择分析模式后将显示动作建议',
                loadingAI: '正在加载AI模型...',
                
                // Status messages
                startingCamera: '启动摄像头...',
                analyzing: '分析中...',
                stopped: '已停止',
                
                // Analysis modes
                liveCameraMode: '实时摄像头模式',
                videoFileMode: '视频文件模式',
                clickToStart: '点击开始进行实时动作分析',
                uploadForAnalysis: '上传视频文件进行动作分析',
                realTimeAnalysis: '实时动作分析',
                videoAnalysisComplete: '视频分析完成',
                
                // Suggestions
                keepStable: '保持身体重心稳定，双脚站稳',
                makeFluid: '动作要更加流畅，避免突然停顿',
                focusCoordination: '注意身体各部分的协调配合',
                improveStroke: '完善击球姿势，手臂充分伸展',
                greatTechnique: '动作很棒，继续保持！',
                
                // Analysis descriptions
                excellentTechnique: '动作非常标准，保持下去！',
                goodForm: '动作良好，继续优化细节',
                basicCorrect: '动作基本正确，需要改进',
                needsAdjustment: '动作需要调整，注意建议',
                studyTutorials: '建议参考教学视频学习基础动作',
                
                // Error messages
                initFailed: '初始化失败：',
                cameraAccess: '无法访问摄像头：',
                switchFailed: '摄像头切换失败：',
                startFirst: '请先开始摄像头分析',
                selectVideo: '请选择有效的视频文件',
                fileSizeLimit: '文件大小不能超过50MB',
                uploadFirst: '请先上传视频文件',
                videoAnalysisFailed: '视频分析失败：',
                noValidData: '未检测到有效的动作数据，请确保视频中有清晰的人体动作',
                noValidMovements: '视频分析未发现有效动作，请上传包含清晰人体动作的视频',
                loadFailed: '视频加载失败：',
                selectTechniqueFirst: '请先选择一个网球技术动作'
            }
        };

        // Language Manager
        class LanguageManager {
            constructor() {
                this.currentLang = 'en';
                this.loadSavedLanguage();
                this.setupLanguageButtons();
            }

            loadSavedLanguage() {
                const saved = localStorage.getItem('tennis-ai-language');
                if (saved && languages[saved]) {
                    this.currentLang = saved;
                }
                this.updateInterface();
            }

            setupLanguageButtons() {
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const lang = btn.dataset.lang;
                        this.switchLanguage(lang);
                    });
                });
            }

            switchLanguage(lang) {
                if (!languages[lang]) return;
                
                this.currentLang = lang;
                localStorage.setItem('tennis-ai-language', lang);
                
                // Update button states
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.lang === lang);
                });
                
                this.updateInterface();
            }

            updateInterface() {
                const texts = languages[this.currentLang];
                
                // Update all elements with data-text attribute
                document.querySelectorAll('[data-text]').forEach(element => {
                    const key = element.dataset.text;
                    if (texts[key]) {
                        if (element.tagName === 'INPUT') {
                            element.placeholder = texts[key];
                        } else {
                            element.innerHTML = texts[key];
                        }
                    }
                });

                // Update button active state on load
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.lang === this.currentLang);
                });
            }

            getText(key) {
                return languages[this.currentLang][key] || key;
            }
        }

        // Initialize language manager
        const langManager = new LanguageManager();
        class TennisAnalyzer {
            constructor() {
                this.pose = null;
                this.camera = null;
                this.videoElement = document.getElementById('videoElement');
                this.uploadVideoElement = document.getElementById('uploadVideoElement');
                this.canvasElement = document.getElementById('canvasElement');
                this.uploadCanvasElement = document.getElementById('uploadCanvasElement');
                this.canvasCtx = this.canvasElement.getContext('2d');
                this.uploadCanvasCtx = this.uploadCanvasElement.getContext('2d');
                this.isAnalyzing = false;
                this.isUploadMode = false;
                this.frameCount = 0;
                this.poseHistory = [];
                this.currentFacingMode = 'user'; // 'user' for front camera, 'environment' for rear camera
                this.selectedTechnique = null; // Selected tennis technique
                this.currentMetrics = {
                    metric1: 0,
                    metric2: 0,
                    metric3: 0,
                    overall: 0
                };
                
                // Ensure langManager is available
                this.langManager = window.langManager;
                
                // Technique-specific metrics configuration
                this.techniqueMetrics = {
                    serve: ['serveMetric1', 'serveMetric2', 'serveMetric3'],
                    forehand: ['forehandMetric1', 'forehandMetric2', 'forehandMetric3'],
                    backhand: ['backhandMetric1', 'backhandMetric2', 'backhandMetric3'],
                    volley: ['volleyMetric1', 'volleyMetric2', 'volleyMetric3'],
                    slice: ['sliceMetric1', 'sliceMetric2', 'sliceMetric3'],
                    overhead: ['overheadMetric1', 'overheadMetric2', 'overheadMetric3']
                };
                
                this.init();
            }
            
            // Helper method for getting translated text
            getText(key) {
                return this.langManager ? this.langManager.getText(key) : key;
            }
            
            selectTechnique(technique) {
                // Remove previous selection
                document.querySelectorAll('.technique-card').forEach(card => {
                    card.classList.remove('selected');
                });
                
                // Add selection to clicked card
                document.querySelector(`[data-technique="${technique}"]`).classList.add('selected');
                
                // Update selected technique
                this.selectedTechnique = technique;
                
                // Show technique info
                this.updateTechniqueInfo(technique);
                
                // Enable analysis controls
                this.enableAnalysisControls();
                
                // Hide selection required warning
                document.getElementById('selectionRequired').classList.remove('show');
            }
            
            updateTechniqueInfo(technique) {
                const infoPanel = document.getElementById('selectedTechniqueInfo');
                const nameElement = document.getElementById('selectedTechniqueName');
                const metricsContainer = document.getElementById('techniqueMetrics');
                
                // Update technique name and icon
                const icons = {
                    serve: '🎾',
                    forehand: '🏸',
                    backhand: '🎯',
                    volley: '⚡',
                    slice: '🌀',
                    overhead: '💥'
                };
                
                nameElement.innerHTML = `
                    <span>${icons[technique]}</span>
                    <span>${this.getText('selectedTechniqueTitle')}: ${this.getText(technique)}</span>
                `;
                
                // Update metrics display
                const metrics = this.techniqueMetrics[technique];
                metricsContainer.innerHTML = '';
                
                metrics.forEach(metricKey => {
                    const metricDiv = document.createElement('div');
                    metricDiv.className = 'metric-preview';
                    metricDiv.textContent = this.getText(metricKey);
                    metricsContainer.appendChild(metricDiv);
                });
                
                // Show the info panel
                infoPanel.classList.add('show');
                
                // Update analysis panel metrics
                this.updateAnalysisMetrics(technique);
            }
            
            updateAnalysisMetrics(technique) {
                const metrics = this.techniqueMetrics[technique];
                const metricItems = document.querySelectorAll('.metric-item');
                
                metricItems.forEach((item, index) => {
                    if (index < metrics.length) {
                        const label = item.querySelector('.metric-label');
                        label.textContent = this.getText(metrics[index]);
                        item.style.display = 'flex';
                    } else {
                        item.style.display = 'none';
                    }
                });
            }
            
            enableAnalysisControls() {
                const videoSection = document.querySelector('.video-section');
                videoSection.classList.remove('analysis-disabled');
            }
            
            disableAnalysisControls() {
                const videoSection = document.querySelector('.video-section');
                videoSection.classList.add('analysis-disabled');
            }
            
            validateTechniqueSelection() {
                if (!this.selectedTechnique) {
                    document.getElementById('selectionRequired').classList.add('show');
                    setTimeout(() => {
                        document.getElementById('selectionRequired').classList.remove('show');
                    }, 3000);
                    return false;
                }
                return true;
            }
            
            async init() {
                try {
                    this.showLoading(true);
                    await this.initMediaPipe();
                    this.setupEventListeners();
                    this.showLoading(false);
                } catch (error) {
                    this.showError(this.getText('initFailed') + error.message);
                    this.showLoading(false);
                }
            }
            
            async initMediaPipe() {
                this.pose = new Pose({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                    }
                });
                
                this.pose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    enableSegmentation: false,
                    smoothSegmentation: false,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                this.pose.onResults(this.onResults.bind(this));
            }
            
            setupEventListeners() {
                // Mode switching
                document.querySelectorAll('.mode-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => this.switchMode(e.target.dataset.mode));
                });
                
                // Technique selection
                document.querySelectorAll('.technique-card').forEach(card => {
                    card.addEventListener('click', (e) => {
                        const technique = card.dataset.technique;
                        this.selectTechnique(technique);
                    });
                });
                
                // Camera mode controls
                document.getElementById('startBtn').addEventListener('click', () => this.startCameraAnalysis());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopAnalysis());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('cameraSwitchBtn').addEventListener('click', () => this.switchCamera());
                
                // File upload
                const fileInput = document.getElementById('fileInput');
                const uploadArea = document.getElementById('uploadArea');
                
                uploadArea.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.handleFileUpload(e.target.files[0]));
                
                // Drag and drop upload
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const file = e.dataTransfer.files[0];
                    if (file && file.type.startsWith('video/')) {
                        this.handleFileUpload(file);
                    }
                });
                
                // Video controls
                document.getElementById('playPauseBtn').addEventListener('click', () => this.togglePlayPause());
                document.getElementById('analyzeVideoBtn').addEventListener('click', () => this.analyzeUploadedVideo());
                document.getElementById('clearVideoBtn').addEventListener('click', () => this.clearVideo());
                
                // Progress bar control
                document.getElementById('progressBar').addEventListener('click', (e) => this.seekVideo(e));
            }
            
            async switchCamera() {
                if (!this.isAnalyzing) {
                    this.showError(langManager.getText('startFirst'));
                    return;
                }
                
                try {
                    // Stop current camera
                    if (this.camera) {
                        this.camera.stop();
                    }
                    
                    if (this.videoElement.srcObject) {
                        this.videoElement.srcObject.getTracks().forEach(track => track.stop());
                    }
                    
                    // Switch facing mode
                    this.currentFacingMode = this.currentFacingMode === 'user' ? 'environment' : 'user';
                    
                    // Update camera indicator
                    this.updateCameraIndicator();
                    
                    // Restart camera with new facing mode
                    await this.startCameraStream();
                    
                } catch (error) {
                    this.showError(langManager.getText('switchFailed') + error.message);
                    // Revert facing mode if switch failed
                    this.currentFacingMode = this.currentFacingMode === 'user' ? 'environment' : 'user';
                    this.updateCameraIndicator();
                }
            }
            
            updateCameraIndicator() {
                const indicator = document.getElementById('cameraIndicator');
                indicator.textContent = this.currentFacingMode === 'user' ? 
                    langManager.getText('frontCamera') : langManager.getText('rearCamera');
            }
            
            switchMode(mode) {
                document.querySelectorAll('.mode-tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.mode-content').forEach(content => content.classList.remove('active'));
                
                document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
                document.getElementById(`${mode}Mode`).classList.add('active');
                
                this.isUploadMode = mode === 'upload';
                this.reset();
                
                if (mode === 'camera') {
                    this.updateAnalysisPanel('--', this.getText('liveCameraMode'), this.getText('clickToStart'));
                } else {
                    this.updateAnalysisPanel('--', this.getText('videoFileMode'), this.getText('uploadForAnalysis'));
                }
                
                // Ensure controls are disabled until technique is selected
                if (!this.selectedTechnique) {
                    this.disableAnalysisControls();
                }
            }
            
            async handleFileUpload(file) {
                if (!file || !file.type.startsWith('video/')) {
                    this.showError(langManager.getText('selectVideo'));
                    return;
                }
                
                if (file.size > 50 * 1024 * 1024) { // 50MB limit
                    this.showError(langManager.getText('fileSizeLimit'));
                    return;
                }
                
                try {
                    const url = URL.createObjectURL(file);
                    this.uploadVideoElement.src = url;
                    
                    this.uploadVideoElement.onloadedmetadata = () => {
                        document.getElementById('uploadArea').style.display = 'none';
                        document.getElementById('uploadVideoContainer').style.display = 'block';
                        document.getElementById('videoControls').classList.add('show');
                        
                        // Set canvas dimensions
                        this.uploadCanvasElement.width = this.uploadVideoElement.videoWidth;
                        this.uploadCanvasElement.height = this.uploadVideoElement.videoHeight;
                        
                        this.updateTimeDisplay();
                        this.updateAnalysisPanel('--', langManager.getText('videoLoaded'), 
                            langManager.getText('uploadForAnalysis').replace('Upload a video file for motion analysis', 'Click analyze button to process the video'));
                    };
                    
                    // Video time update
                    this.uploadVideoElement.addEventListener('timeupdate', () => {
                        this.updateTimeDisplay();
                        this.updateProgressBar();
                    });
                    
                } catch (error) {
                    this.showError(langManager.getText('loadFailed') + error.message);
                }
            }
            
            togglePlayPause() {
                const video = this.uploadVideoElement;
                const btn = document.getElementById('playPauseBtn');
                
                if (video.paused) {
                    video.play();
                    btn.textContent = langManager.getText('pause');
                } else {
                    video.pause();
                    btn.textContent = langManager.getText('play');
                }
            }
            
            updateTimeDisplay() {
                const video = this.uploadVideoElement;
                document.getElementById('currentTime').textContent = this.formatTime(video.currentTime);
                document.getElementById('totalTime').textContent = this.formatTime(video.duration);
            }
            
            updateProgressBar() {
                const video = this.uploadVideoElement;
                const progress = (video.currentTime / video.duration) * 100;
                document.getElementById('progressFill').style.width = `${progress}%`;
            }
            
            seekVideo(e) {
                const progressBar = document.getElementById('progressBar');
                const rect = progressBar.getBoundingClientRect();
                const percentage = (e.clientX - rect.left) / rect.width;
                this.uploadVideoElement.currentTime = percentage * this.uploadVideoElement.duration;
            }
            
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            clearVideo() {
                this.uploadVideoElement.src = '';
                document.getElementById('uploadArea').style.display = 'block';
                document.getElementById('uploadVideoContainer').style.display = 'none';
                document.getElementById('videoControls').classList.remove('show');
                document.getElementById('analysisProgress').classList.remove('show');
                document.getElementById('fileInput').value = '';
                
                this.updateAnalysisPanel('--', langManager.getText('videoFileMode'), langManager.getText('uploadForAnalysis'));
                this.resetMetrics();
            }
            
            async analyzeUploadedVideo() {
                if (!this.uploadVideoElement.src) {
                    this.showError(langManager.getText('uploadFirst'));
                    return;
                }
                
                this.isAnalyzing = true;
                document.getElementById('analysisProgress').classList.add('show');
                document.getElementById('analyzeVideoBtn').disabled = true;
                
                // Reset analysis data
                this.frameCount = 0;
                this.poseHistory = [];
                this.currentMetrics = { stability: 0, fluidity: 0, coordination: 0, accuracy: 0 };
                
                try {
                    await this.processVideoFrames();
                } catch (error) {
                    this.showError(langManager.getText('videoAnalysisFailed') + error.message);
                } finally {
                    this.isAnalyzing = false;
                    document.getElementById('analysisProgress').classList.remove('show');
                    document.getElementById('analyzeVideoBtn').disabled = false;
                }
            }
            
            async processVideoFrames() {
                const video = this.uploadVideoElement;
                const canvas = this.uploadCanvasElement;
                const ctx = this.uploadCanvasCtx;
                
                video.currentTime = 0;
                const duration = video.duration;
                const frameRate = 5; // Analyze 5 frames per second
                const frameInterval = 1 / frameRate;
                
                return new Promise((resolve, reject) => {
                    let currentTime = 0;
                    let analysisResults = [];
                    
                    const processFrame = async () => {
                        if (currentTime >= duration || !this.isAnalyzing) {
                            // Analysis complete, calculate final results
                            this.calculateFinalResults(analysisResults);
                            resolve();
                            return;
                        }
                        
                        video.currentTime = currentTime;
                        
                        // Wait for video to seek to specified time
                        await new Promise((frameResolve) => {
                            const checkTime = () => {
                                if (Math.abs(video.currentTime - currentTime) < 0.1) {
                                    frameResolve();
                                } else {
                                    setTimeout(checkTime, 10);
                                }
                            };
                            checkTime();
                        });
                        
                        // Draw current frame to canvas
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        
                        // Send to MediaPipe for pose detection
                        try {
                            await this.pose.send({image: canvas});
                            
                            // Wait for pose detection result
                            await new Promise(resolve => setTimeout(resolve, 100));
                            
                        } catch (error) {
                            console.warn('Frame analysis failed:', error);
                        }
                        
                        // Update progress
                        const progress = (currentTime / duration) * 100;
                        document.getElementById('analysisProgressText').textContent = 
                            `Analyzed ${Math.round(progress)}% (${this.formatTime(currentTime)}/${this.formatTime(duration)})`;
                        
                        currentTime += frameInterval;
                        
                        // Continue processing next frame
                        setTimeout(processFrame, 50);
                    };
                    
                    processFrame();
                });
            }
            
            calculateFinalResults(results) {
                if (this.poseHistory.length === 0) {
                    this.showError(langManager.getText('noValidData'));
                    return;
                }
                
                // Calculate average metrics for entire video
                const avgMetrics = {
                    stability: 0,
                    fluidity: 0,
                    coordination: 0,
                    accuracy: 0
                };
                
                // Analyze all frame data
                let validFrames = 0;
                this.poseHistory.forEach((landmarks, index) => {
                    if (landmarks && landmarks.length > 0) {
                        const frameMetrics = this.calculateFrameMetrics(landmarks, index);
                        avgMetrics.stability += frameMetrics.stability;
                        avgMetrics.fluidity += frameMetrics.fluidity;
                        avgMetrics.coordination += frameMetrics.coordination;
                        avgMetrics.accuracy += frameMetrics.accuracy;
                        validFrames++;
                    }
                });
                
                if (validFrames > 0) {
                    Object.keys(avgMetrics).forEach(key => {
                        avgMetrics[key] = Math.round(avgMetrics[key] / validFrames);
                    });
                    
                    this.currentMetrics = avgMetrics;
                    const overallScore = Math.round(
                        (avgMetrics.stability + avgMetrics.fluidity + avgMetrics.coordination + avgMetrics.accuracy) / 4
                    );
                    
                    this.updateAnalysisPanel(
                        overallScore,
                        langManager.getText('videoAnalysisComplete'),
                        `${langManager.currentLang === 'zh' ? '共分析' : 'Analyzed'} ${validFrames} ${langManager.currentLang === 'zh' ? '帧，' : 'frames, '}${this.getAnalysisDescription(overallScore)}`
                    );
                    
                    this.updateMetrics();
                    this.updateSuggestions(this.generateSuggestions());
                } else {
                    this.showError(langManager.getText('noValidMovements'));
                }
            }
            
            calculateFrameMetrics(landmarks, frameIndex) {
                return {
                    stability: this.calculateStability(landmarks),
                    fluidity: this.calculateFluidity(),
                    coordination: this.calculateCoordination(landmarks),
                    accuracy: this.calculateAccuracy(landmarks)
                };
            }
            
            async startCameraAnalysis() {
                if (this.isUploadMode) return;
                
                try {
                    this.updateStatus('startingCamera');
                    await this.startCameraStream();
                    
                    this.isAnalyzing = true;
                    this.updateStatus('analyzing');
                    this.updateButtons(false);
                    document.getElementById('cameraSwitchBtn').classList.add('show');
                    document.getElementById('cameraIndicator').classList.add('show');
                    
                    this.startAnalysisLoop();
                    
                } catch (error) {
                    this.showError(langManager.getText('cameraAccess') + error.message);
                }
            }
            
            async startCameraStream() {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: 640, 
                        height: 480,
                        facingMode: this.currentFacingMode
                    }
                });
                
                this.videoElement.srcObject = stream;
                this.videoElement.style.display = 'block';
                document.getElementById('placeholder').style.display = 'none';
                
                this.camera = new Camera(this.videoElement, {
                    onFrame: async () => {
                        if (this.isAnalyzing && !this.isUploadMode) {
                            await this.pose.send({image: this.videoElement});
                        }
                    },
                    width: 640,
                    height: 480
                });
                
                await this.camera.start();
                this.updateCameraIndicator();
            }
            
            stopAnalysis() {
                this.isAnalyzing = false;
                this.updateStatus('stopped');
                this.updateButtons(true);
                document.getElementById('cameraSwitchBtn').classList.remove('show');
                document.getElementById('cameraIndicator').classList.remove('show');
                
                if (this.camera) {
                    this.camera.stop();
                }
                
                if (this.videoElement.srcObject) {
                    this.videoElement.srcObject.getTracks().forEach(track => track.stop());
                }
            }
            
            reset() {
                this.stopAnalysis();
                this.frameCount = 0;
                this.poseHistory = [];
                this.currentFacingMode = 'user'; // Reset to front camera
                this.currentMetrics = {
                    stability: 0,
                    fluidity: 0,
                    coordination: 0,
                    accuracy: 0
                };
                
                if (!this.isUploadMode) {
                    this.videoElement.style.display = 'none';
                    document.getElementById('placeholder').style.display = 'block';
                    this.canvasCtx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
                    this.updateAnalysisPanel('--', langManager.getText('liveCameraMode'), langManager.getText('clickToStart'));
                } else {
                    this.clearVideo();
                }
                
                this.resetMetrics();
                this.updateSuggestions([{text: langManager.getText('selectModeForSuggestions')}]);
                this.updateStatus('ready');
                this.updateCameraIndicator();
            }
            
            onResults(results) {
                if (!this.isAnalyzing) return;
                
                const canvas = this.isUploadMode ? this.uploadCanvasElement : this.canvasElement;
                const ctx = this.isUploadMode ? this.uploadCanvasCtx : this.canvasCtx;
                const video = this.isUploadMode ? this.uploadVideoElement : this.videoElement;
                
                canvas.width = video.videoWidth || video.width || 640;
                canvas.height = video.videoHeight || video.height || 480;
                
                ctx.save();
                if (!this.isUploadMode) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                
                if (results.poseLandmarks) {
                    this.drawPose(results.poseLandmarks, ctx, canvas);
                    
                    if (!this.isUploadMode) {
                        // Real-time mode: analyze immediately
                        this.analyzePose(results.poseLandmarks);
                    } else {
                        // Video mode: store data for later analysis
                        this.poseHistory.push(results.poseLandmarks);
                    }
                }
                
                ctx.restore();
                this.frameCount++;
            }
            
            drawPose(landmarks, ctx, canvas) {
                // Draw connections
                this.drawConnections(landmarks, [
                    [11, 12], [11, 13], [13, 15], [12, 14], [14, 16], // Arms
                    [11, 23], [12, 24], [23, 24], // Torso
                    [23, 25], [25, 27], [24, 26], [26, 28] // Legs
                ], '#00ff00', 2, ctx, canvas);
                
                // Draw landmarks
                this.drawLandmarks(landmarks, '#ff0000', 4, ctx, canvas);
            }
            
            drawConnections(landmarks, connections, color, width, ctx, canvas) {
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                
                connections.forEach(([start, end]) => {
                    const startPoint = landmarks[start];
                    const endPoint = landmarks[end];
                    
                    if (startPoint && endPoint) {
                        ctx.beginPath();
                        ctx.moveTo(
                            startPoint.x * canvas.width,
                            startPoint.y * canvas.height
                        );
                        ctx.lineTo(
                            endPoint.x * canvas.width,
                            endPoint.y * canvas.height
                        );
                        ctx.stroke();
                    }
                });
            }
            
            drawLandmarks(landmarks, color, radius, ctx, canvas) {
                ctx.fillStyle = color;
                
                landmarks.forEach(landmark => {
                    ctx.beginPath();
                    ctx.arc(
                        landmark.x * canvas.width,
                        landmark.y * canvas.height,
                        radius,
                        0,
                        2 * Math.PI
                    );
                    ctx.fill();
                });
            }
            
            analyzePose(landmarks) {
                this.poseHistory.push(landmarks);
                if (this.poseHistory.length > 30) {
                    this.poseHistory.shift();
                }
                
                const stability = this.calculateStability(landmarks);
                const fluidity = this.calculateFluidity();
                const coordination = this.calculateCoordination(landmarks);
                const accuracy = this.calculateAccuracy(landmarks);
                
                this.currentMetrics = {
                    stability: Math.round(stability),
                    fluidity: Math.round(fluidity),
                    coordination: Math.round(coordination),
                    accuracy: Math.round(accuracy)
                };
                
                const overallScore = Math.round((stability + fluidity + coordination + accuracy) / 4);
                
                this.updateAnalysisPanel(
                    overallScore,
                    langManager.getText('realTimeAnalysis'),
                    this.getAnalysisDescription(overallScore)
                );
                
                this.updateMetrics();
                this.updateSuggestions(this.generateSuggestions());
            }
            
            calculateTechniqueMetrics(landmarks, technique) {
                // Base calculations that can be reused
                const stability = this.calculateStability(landmarks);
                const fluidity = this.calculateFluidity();
                const coordination = this.calculateCoordination(landmarks);
                const accuracy = this.calculateAccuracy(landmarks);
                
                // Technique-specific calculations
                switch (technique) {
                    case 'serve':
                        return {
                            metric1: this.calculateBallTossStability(landmarks), // Ball Toss Stability
                            metric2: coordination, // Body Coordination
                            metric3: this.calculateLandingAccuracy(landmarks) // Landing Accuracy
                        };
                    
                    case 'forehand':
                        return {
                            metric1: this.calculatePreparationBackswing(landmarks), // Preparation & Backswing
                            metric2: this.calculateContactPointPosition(landmarks), // Contact Point Position
                            metric3: this.calculateFollowThrough(landmarks) // Follow-through Motion
                        };
                    
                    case 'backhand':
                        return {
                            metric1: this.calculateGripPosition(landmarks), // Grip Position
                            metric2: this.calculateWeightTransfer(landmarks), // Weight Transfer
                            metric3: this.calculateContactPointControl(landmarks) // Contact Point Control
                        };
                    
                    case 'volley':
                        return {
                            metric1: this.calculateFootworkAdjustment(landmarks), // Footwork Adjustment
                            metric2: this.calculateRacketFaceControl(landmarks), // Racket Face Control
                            metric3: this.calculateContactPointHeight(landmarks) // Contact Point Height
                        };
                    
                    case 'slice':
                        return {
                            metric1: this.calculateRacketFaceAngle(landmarks), // Racket Face Angle
                            metric2: this.calculateSwingTrajectory(landmarks), // Swing Trajectory
                            metric3: this.calculateSpinConsistency(landmarks) // Spin Consistency
                        };
                    
                    case 'overhead':
                        return {
                            metric1: this.calculateFootworkSpeed(landmarks), // Footwork Speed
                            metric2: this.calculateContactHeight(landmarks), // Contact Height
                            metric3: this.calculatePowerControl(landmarks) // Power & Control
                        };
                    
                    default:
                        // Fallback to general metrics
                        return {
                            metric1: stability,
                            metric2: fluidity,
                            metric3: coordination
                        };
                }
            }
            
            // Serve-specific calculations
            calculateBallTossStability(landmarks) {
                // Simplified: measure arm stability during toss motion
                const rightShoulder = landmarks[12];
                const rightElbow = landmarks[14];
                const rightWrist = landmarks[16];
                
                if (!rightShoulder || !rightElbow || !rightWrist) return 50;
                
                const armAngle = this.calculateAngle(rightShoulder, rightElbow, rightWrist);
                const stability = Math.max(0, 100 - Math.abs(armAngle - 140) * 2);
                return Math.min(100, stability);
            }
            
            calculateLandingAccuracy(landmarks) {
                // Simplified: measure body balance after serve
                return this.calculateStability(landmarks);
            }
            
            // Forehand-specific calculations
            calculatePreparationBackswing(landmarks) {
                // Measure shoulder turn and racket position
                const leftShoulder = landmarks[11];
                const rightShoulder = landmarks[12];
                
                if (!leftShoulder || !rightShoulder) return 50;
                
                const shoulderAngle = Math.abs(leftShoulder.y - rightShoulder.y) * 100;
                return Math.max(0, Math.min(100, 80 + shoulderAngle));
            }
            
            calculateContactPointPosition(landmarks) {
                // Measure arm extension at contact
                const rightShoulder = landmarks[12];
                const rightWrist = landmarks[16];
                
                if (!rightShoulder || !rightWrist) return 50;
                
                const extension = this.calculateDistance(rightShoulder, rightWrist);
                return Math.max(0, Math.min(100, extension * 300));
            }
            
            calculateFollowThrough(landmarks) {
                // Measure follow-through motion fluidity
                return this.calculateFluidity();
            }
            
            // Backhand-specific calculations
            calculateGripPosition(landmarks) {
                // Simplified: measure wrist alignment
                const leftWrist = landmarks[15];
                const leftElbow = landmarks[13];
                
                if (!leftWrist || !leftElbow) return 50;
                
                const alignment = Math.abs(leftWrist.x - leftElbow.x) * 100;
                return Math.max(0, Math.min(100, 90 - alignment));
            }
            
            calculateWeightTransfer(landmarks) {
                // Measure hip and shoulder coordination
                return this.calculateCoordination(landmarks);
            }
            
            calculateContactPointControl(landmarks) {
                // Measure contact point consistency
                return this.calculateAccuracy(landmarks);
            }
            
            // Volley-specific calculations
            calculateFootworkAdjustment(landmarks) {
                // Measure leg positioning and movement
                const leftAnkle = landmarks[27];
                const rightAnkle = landmarks[28];
                
                if (!leftAnkle || !rightAnkle) return 50;
                
                const footPosition = this.calculateDistance(leftAnkle, rightAnkle);
                return Math.max(0, Math.min(100, footPosition * 200 + 60));
            }
            
            calculateRacketFaceControl(landmarks) {
                // Measure arm positioning for racket control
                return this.calculateAccuracy(landmarks);
            }
            
            calculateContactPointHeight(landmarks) {
                // Measure contact point height consistency
                const rightWrist = landmarks[16];
                const rightShoulder = landmarks[12];
                
                if (!rightWrist || !rightShoulder) return 50;
                
                const height = Math.abs(rightWrist.y - rightShoulder.y) * 100;
                return Math.max(0, Math.min(100, 90 - height));
            }
            
            // Slice-specific calculations
            calculateRacketFaceAngle(landmarks) {
                // Measure wrist angle for slice technique
                const rightWrist = landmarks[16];
                const rightElbow = landmarks[14];
                
                if (!rightWrist || !rightElbow) return 50;
                
                const angle = Math.abs(rightWrist.y - rightElbow.y) * 150;
                return Math.max(0, Math.min(100, 80 + angle));
            }
            
            calculateSwingTrajectory(landmarks) {
                // Measure swing path consistency
                return this.calculateFluidity();
            }
            
            calculateSpinConsistency(landmarks) {
                // Measure motion consistency for spin generation
                return this.calculateStability(landmarks);
            }
            
            // Overhead-specific calculations
            calculateFootworkSpeed(landmarks) {
                // Measure quick positioning for overhead
                if (this.poseHistory.length < 5) return 50;
                
                const recent = this.poseHistory.slice(-5);
                let movement = 0;
                
                for (let i = 1; i < recent.length; i++) {
                    const prev = recent[i-1][27] || recent[i-1][28]; // ankle
                    const curr = recent[i][27] || recent[i][28];
                    
                    if (prev && curr) {
                        movement += this.calculateDistance(prev, curr);
                    }
                }
                
                return Math.max(0, Math.min(100, movement * 1000 + 70));
            }
            
            calculateContactHeight(landmarks) {
                // Measure overhead contact height
                const rightWrist = landmarks[16];
                const nose = landmarks[0];
                
                if (!rightWrist || !nose) return 50;
                
                const height = nose.y - rightWrist.y;
                return Math.max(0, Math.min(100, height * 200 + 60));
            }
            
            calculatePowerControl(landmarks) {
                // Measure power and control balance
                const power = this.calculateCoordination(landmarks);
                const control = this.calculateAccuracy(landmarks);
                return (power + control) / 2;
            }
            
            // Base calculation methods (reused from original)
            calculateStability(landmarks) {
                if (this.poseHistory.length < 5) return 50;
                
                const centerOfMass = this.getCenterOfMass(landmarks);
                const recentCenters = this.poseHistory.slice(-5).map(pose => this.getCenterOfMass(pose));
                
                let totalVariation = 0;
                for (let i = 1; i < recentCenters.length; i++) {
                    const distance = Math.sqrt(
                        Math.pow(recentCenters[i].x - recentCenters[i-1].x, 2) +
                        Math.pow(recentCenters[i].y - recentCenters[i-1].y, 2)
                    );
                    totalVariation += distance;
                }
                
                const avgVariation = totalVariation / (recentCenters.length - 1);
                return Math.max(0, 100 - avgVariation * 1000);
            }
            
            calculateFluidity() {
                if (this.poseHistory.length < 10) return 50;
                
                const shoulderAngles = this.poseHistory.slice(-10).map(pose => 
                    this.calculateAngle(pose[11], pose[13], pose[15])
                );
                
                let smoothness = 0;
                for (let i = 2; i < shoulderAngles.length; i++) {
                    const acceleration = shoulderAngles[i] - 2 * shoulderAngles[i-1] + shoulderAngles[i-2];
                    smoothness += Math.abs(acceleration);
                }
                
                return Math.max(0, 100 - smoothness * 2);
            }
            
            calculateCoordination(landmarks) {
                const leftArm = this.calculateAngle(landmarks[11], landmarks[13], landmarks[15]);
                const rightArm = this.calculateAngle(landmarks[12], landmarks[14], landmarks[16]);
                const torso = this.calculateAngle(landmarks[11], landmarks[23], landmarks[25]);
                
                let coordinationScore = 70;
                
                const armSymmetry = Math.abs(leftArm - rightArm);
                if (armSymmetry < 30) coordinationScore += 15;
                else if (armSymmetry < 60) coordinationScore += 10;
                
                if (torso > 160 && torso < 180) coordinationScore += 15;
                
                return Math.min(100, coordinationScore);
            }
            
            calculateAccuracy(landmarks) {
                const wrist = landmarks[16] || landmarks[15];
                const shoulder = landmarks[12] || landmarks[11];
                const hip = landmarks[24] || landmarks[23];
                
                if (!wrist || !shoulder || !hip) return 50;
                
                let accuracyScore = 60;
                
                const armExtension = this.calculateDistance(shoulder, wrist);
                if (armExtension > 0.3) accuracyScore += 20;
                
                const balance = Math.abs(shoulder.x - hip.x);
                if (balance < 0.1) accuracyScore += 20;
                
                return Math.min(100, accuracyScore);
            }
            
            getCenterOfMass(landmarks) {
                const keyPoints = [landmarks[11], landmarks[12], landmarks[23], landmarks[24]];
                let sumX = 0, sumY = 0, count = 0;
                
                keyPoints.forEach(point => {
                    if (point) {
                        sumX += point.x;
                        sumY += point.y;
                        count++;
                    }
                });
                
                return { x: sumX / count, y: sumY / count };
            }
            
            calculateAngle(a, b, c) {
                if (!a || !b || !c) return 0;
                
                const ab = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
                const bc = Math.sqrt(Math.pow(c.x - b.x, 2) + Math.pow(c.y - b.y, 2));
                const ac = Math.sqrt(Math.pow(c.x - a.x, 2) + Math.pow(c.y - a.y, 2));
                
                const cosine = (ab * ab + bc * bc - ac * ac) / (2 * ab * bc);
                const angle = Math.acos(Math.max(-1, Math.min(1, cosine)));
                
                return angle * 180 / Math.PI;
            }
            
            calculateDistance(a, b) {
                if (!a || !b) return 0;
                return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
            }
            calculateStability(landmarks) {
                if (this.poseHistory.length < 5) return 50;
                
                const centerOfMass = this.getCenterOfMass(landmarks);
                const recentCenters = this.poseHistory.slice(-5).map(pose => this.getCenterOfMass(pose));
                
                let totalVariation = 0;
                for (let i = 1; i < recentCenters.length; i++) {
                    const distance = Math.sqrt(
                        Math.pow(recentCenters[i].x - recentCenters[i-1].x, 2) +
                        Math.pow(recentCenters[i].y - recentCenters[i-1].y, 2)
                    );
                    totalVariation += distance;
                }
                
                const avgVariation = totalVariation / (recentCenters.length - 1);
                return Math.max(0, 100 - avgVariation * 1000);
            }
            
            calculateFluidity() {
                if (this.poseHistory.length < 10) return 50;
                
                const shoulderAngles = this.poseHistory.slice(-10).map(pose => 
                    this.calculateAngle(pose[11], pose[13], pose[15])
                );
                
                let smoothness = 0;
                for (let i = 2; i < shoulderAngles.length; i++) {
                    const acceleration = shoulderAngles[i] - 2 * shoulderAngles[i-1] + shoulderAngles[i-2];
                    smoothness += Math.abs(acceleration);
                }
                
                return Math.max(0, 100 - smoothness * 2);
            }
            
            calculateCoordination(landmarks) {
                const leftArm = this.calculateAngle(landmarks[11], landmarks[13], landmarks[15]);
                const rightArm = this.calculateAngle(landmarks[12], landmarks[14], landmarks[16]);
                const torso = this.calculateAngle(landmarks[11], landmarks[23], landmarks[25]);
                
                let coordinationScore = 70;
                
                const armSymmetry = Math.abs(leftArm - rightArm);
                if (armSymmetry < 30) coordinationScore += 15;
                else if (armSymmetry < 60) coordinationScore += 10;
                
                if (torso > 160 && torso < 180) coordinationScore += 15;
                
                return Math.min(100, coordinationScore);
            }
            
            calculateAccuracy(landmarks) {
                const wrist = landmarks[16] || landmarks[15];
                const shoulder = landmarks[12] || landmarks[11];
                const hip = landmarks[24] || landmarks[23];
                
                if (!wrist || !shoulder || !hip) return 50;
                
                let accuracyScore = 60;
                
                const armExtension = this.calculateDistance(shoulder, wrist);
                if (armExtension > 0.3) accuracyScore += 20;
                
                const balance = Math.abs(shoulder.x - hip.x);
                if (balance < 0.1) accuracyScore += 20;
                
                return Math.min(100, accuracyScore);
            }
            
            getCenterOfMass(landmarks) {
                const keyPoints = [landmarks[11], landmarks[12], landmarks[23], landmarks[24]];
                let sumX = 0, sumY = 0, count = 0;
                
                keyPoints.forEach(point => {
                    if (point) {
                        sumX += point.x;
                        sumY += point.y;
                        count++;
                    }
                });
                
                return { x: sumX / count, y: sumY / count };
            }
            
            calculateAngle(a, b, c) {
                if (!a || !b || !c) return 0;
                
                const ab = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
                const bc = Math.sqrt(Math.pow(c.x - b.x, 2) + Math.pow(c.y - b.y, 2));
                const ac = Math.sqrt(Math.pow(c.x - a.x, 2) + Math.pow(c.y - a.y, 2));
                
                const cosine = (ab * ab + bc * bc - ac * ac) / (2 * ab * bc);
                const angle = Math.acos(Math.max(-1, Math.min(1, cosine)));
                
                return angle * 180 / Math.PI;
            }
            
            calculateDistance(a, b) {
                if (!a || !b) return 0;
                return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
            }
            
            startAnalysisLoop() {
                if (!this.isAnalyzing || this.isUploadMode) return;
                
                setTimeout(() => {
                    if (this.isAnalyzing && !this.isUploadMode) {
                        this.startAnalysisLoop();
                    }
                }, 1000);
            }
            
            generateSuggestions() {
                const suggestions = [];
                const metrics = this.currentMetrics;
                
                if (metrics.stability < 70) {
                    suggestions.push({text: this.getText('keepStable')});
                }
                
                if (metrics.fluidity < 70) {
                    suggestions.push({text: this.getText('makeFluid')});
                }
                
                if (metrics.coordination < 70) {
                    suggestions.push({text: this.getText('focusCoordination')});
                }
                
                if (metrics.accuracy < 70) {
                    suggestions.push({text: this.getText('improveStroke')});
                }
                
                if (suggestions.length === 0) {
                    suggestions.push({text: this.getText('greatTechnique')});
                }
                
                return suggestions;
            }
            
            getAnalysisDescription(score) {
                if (score >= 90) return this.getText('excellentTechnique');
                if (score >= 80) return this.getText('goodForm');
                if (score >= 70) return this.getText('basicCorrect');
                if (score >= 60) return this.getText('needsAdjustment');
                return this.getText('studyTutorials');
            }
            
            updateAnalysisPanel(score, title, description) {
                document.getElementById('scoreNumber').textContent = score;
                document.getElementById('analysisTitle').textContent = title;
                document.getElementById('analysisDesc').textContent = description;
                
                if (score !== '--') {
                    const degree = (score / 100) * 360;
                    const color = score >= 80 ? '#48bb78' : score >= 60 ? '#ed8936' : '#e53e3e';
                    document.getElementById('scoreCircle').style.background = 
                        `conic-gradient(${color} 0deg ${degree}deg, #e2e8f0 ${degree}deg 360deg)`;
                }
            }
            
            updateMetrics() {
                const metrics = this.currentMetrics;
                const metricItems = document.querySelectorAll('.metric-item');
                
                // Update only the visible metrics based on selected technique
                if (this.selectedTechnique && this.techniqueMetrics[this.selectedTechnique]) {
                    const techniqueMetricKeys = this.techniqueMetrics[this.selectedTechnique];
                    
                    metricItems.forEach((item, index) => {
                        const valueElement = item.querySelector('.metric-value');
                        const fillElement = item.querySelector('.metric-fill');
                        
                        if (index < techniqueMetricKeys.length) {
                            const metricKey = `metric${index + 1}`;
                            const value = metrics[metricKey] || 0;
                            
                            valueElement.textContent = value;
                            fillElement.style.width = `${value}%`;
                        }
                    });
                } else {
                    // Fallback to default display
                    metricItems.forEach((item, index) => {
                        const valueElement = item.querySelector('.metric-value');
                        const fillElement = item.querySelector('.metric-fill');
                        
                        valueElement.textContent = '--';
                        fillElement.style.width = '0%';
                    });
                }
            }
            
            resetMetrics() {
                const metricItems = document.querySelectorAll('.metric-item');
                
                metricItems.forEach(item => {
                    const valueElement = item.querySelector('.metric-value');
                    const fillElement = item.querySelector('.metric-fill');
                    
                    valueElement.textContent = '--';
                    fillElement.style.width = '0%';
                });
                
                // Reset all metric items to be visible with default labels
                metricItems.forEach((item, index) => {
                    const label = item.querySelector('.metric-label');
                    const defaultLabels = ['postureStability', 'motionFluidity', 'coordination', 'technicalAccuracy'];
                    
                    if (index < defaultLabels.length) {
                        label.textContent = this.getText(defaultLabels[index]);
                        item.style.display = 'flex';
                    }
                });
            }
            
            updateSuggestions(suggestions) {
                const container = document.getElementById('suggestionsList');
                container.innerHTML = '';
                
                suggestions.forEach((suggestion, index) => {
                    const item = document.createElement('div');
                    item.className = 'suggestion-item';
                    item.style.animationDelay = `${index * 0.1}s`;
                    item.innerHTML = `
                        <div class="suggestion-icon"></div>
                        <span>${suggestion.text}</span>
                    `;
                    container.appendChild(item);
                });
            }
            
            updateStatus(statusKey) {
                const indicator = document.getElementById('statusIndicator');
                indicator.textContent = this.getText(statusKey);
                
                if (statusKey.includes('analyzing')) {
                    indicator.style.background = 'rgba(237, 137, 54, 0.1)';
                    indicator.style.color = '#ed8936';
                } else if (statusKey.includes('ready')) {
                    indicator.style.background = 'rgba(72, 187, 120, 0.1)';
                    indicator.style.color = '#38a169';
                } else {
                    indicator.style.background = 'rgba(113, 128, 150, 0.1)';
                    indicator.style.color = '#718096';
                }
            }
            
            updateButtons(isStart) {
                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                
                if (isStart) {
                    startBtn.style.display = 'flex';
                    stopBtn.style.display = 'none';
                } else {
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'flex';
                }
            }
            
            showLoading(show) {
                document.getElementById('loadingIndicator').style.display = show ? 'block' : 'none';
            }
            
            showError(message) {
                const errorDiv = document.getElementById('errorMessage');
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000);
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            new TennisAnalyzer();
        });
    </script>
</body>
</html>